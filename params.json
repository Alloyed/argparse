{"name":"Argparse tutorial","tagline":"","body":"* [Creating a parser](#creating-a-parser)\r\n* [Parsing command line arguments](#parsing-command-line-arguments)\r\n    - [Error handling](#error-handling)\r\n    - [Help option](#help-option)\r\n    - [Typo autocorrection](#typo-autocorrection)\r\n* [Configuring parser](#configuring-parser)\r\n* [Adding arguments](#adding-arguments)\r\n    - [Setting number of arguments](#setting-number-of-arguments)\r\n* [Adding options](#adding-options)\r\n    - [Flags](#flags)\r\n    - [Control characters](#control-characters)\r\n    - [Setting number of arguments](#setting-number-of-arguments)\r\n    - [Setting number of invocations](#setting-number-of-invocations)\r\n* [Commands](#commands)\r\n    - [Adding elements to commands](#adding-elements-to-commands)\r\n    - [Making a command optional](#making-a-command optional)\r\n* [Default values](#default-values)\r\n    - [Default mode](#default-mode)\r\n* [Converters](#converters)\r\n    - [Table converters](#table-converters)\r\n* [Actions](#actions)\r\n* [Miscellaneous](#miscellaneous)\r\n    - [Overwriting default help option](#overwriting-default-help-option)\r\n    - [Configuring usage and help messages](#configuring-usage-and-help-messages)\r\n        + [Description and epilog](#description-and-epilog)\r\n        + [Argument placeholder](#argument-placeholder)\r\n    - [Prohibiting overuse of options](#prohibiting-overuse-of-options)\r\n    - [Generating usage and help messages](#generating-usage-and-help-messages)\r\n    - [Parsing algorithm](#parsing-algorithm)\r\n\r\n## Creating a parser\r\n\r\nThe module is a function which, when called, creates an instance of the Parser class. \r\n\r\n```lua\r\n-- script.lua\r\nlocal argparse = require \"argparse\"\r\nlocal parser = argparse()\r\n```\r\n\r\n`parser` is now an empty parser which does not recognize any command line arguments or options. \r\n\r\n## Parsing command line arguments\r\n\r\n`:parse([cmdline])` method of the Parser class returns a table with processed data from the command line or `cmdline` array. \r\n\r\n```lua\r\nlocal args = parser:parse()\r\nfor k, v in pairs(args) do print(k, v) end\r\n```\r\n\r\nWhen executed, this script prints nothing because the parser is empty and no command line arguments were supplied. \r\n\r\n```bash\r\n$ lua script.lua\r\n```\r\n\r\n### Error handling\r\n\r\nIf the provided command line arguments are not recognized by the parser, it will print an error message and call `os.exit(1)`. \r\n\r\n```bash\r\n$ lua script.lua foo\r\n```\r\n\r\n```\r\nUsage: script.lua [-h]\r\n\r\nError: too many arguments\r\n```\r\n\r\nIf halting the program is undesirable, `:pparse([cmdline])` method should be used. It returns boolean flag indicating success of parsing and result or error message. \r\n\r\nAn error can raised manually using `:error()` method. \r\n\r\n```lua\r\nparser:error(\"manual argument validation failed\")\r\n```\r\n\r\n```\r\nUsage: script.lua [-h]\r\n\r\nError: manual argument validation failed\r\n```\r\n\r\n### Help option\r\n\r\nAs the automatically generated usage message states, there is a help option `-h` added to any parser by default. \r\n\r\nWhen a help option is used, parser will print a help message and call `os.exit(0)`. \r\n\r\n```bash\r\n$ lua script.lua -h\r\n```\r\n\r\n```\r\nUsage: script.lua [-h]\r\n\r\nOptions: \r\n   -h, --help            Show this help message and exit. \r\n```\r\n\r\n### Typo autocorrection\r\n\r\nWhen an option is not recognized by the parser, but there is an option with a similar name, a suggestion is automatically added to the error message. \r\n\r\n```bash\r\n$ lua script.lua --hepl\r\n```\r\n\r\n```\r\nUsage: script.lua [-h]\r\n\r\nError: unknown option '--hepl'\r\nDid you mean '--help'?\r\n```\r\n\r\n## Configuring parser\r\n\r\nParsers have several fields affecting their behavior. For example, `description` field sets the text to be displayed in the help message between the usage message and the listings of options and arguments. Another is `name`, which overwrites the name of the program which is used in the usage message(default value is inferred from command line arguments). \r\n\r\nThere are several ways to set fields. The first is to call a parser with a table containing some fields. \r\n\r\n```lua\r\nlocal parser = argparse() {\r\n   name = \"script\",\r\n   description = \"A testing script. \"\r\n}\r\n```\r\n\r\nThe second is to chain setter methods of Parser object. \r\n\r\n```lua\r\nlocal parser = argparse()\r\n   :name \"script\"\r\n   :description \"A testing script. \"\r\n```\r\n\r\nAs a special case, `name` field can be set by calling a parser with a string. \r\n\r\n```lua\r\nlocal parser = argparse \"script\"\r\n   :description \"A testing script. \"\r\n```\r\n\r\n## Adding arguments\r\n\r\nPositional arguments can be added using `:argument()` method. It returns an Argument instance, which can be configured in the same way as Parsers. The `name` field is required. \r\n\r\n```lua\r\nparser:argument \"input\" -- sugar for :argument():name \"input\"\r\n```\r\n\r\n```bash\r\n$ lua script.lua foo\r\n```\r\n\r\n```\r\ninput\tfoo\r\n```\r\n\r\nThe data passed to the argument is stored in the result table at index `input` because it is the argument's name. The index can be changed using `target` field. \r\n\r\n### Setting number of arguments\r\n\r\n`args` field sets how many command line arguments the argument consumes. Its value is interpreted as follows: \r\n\r\nValue | Interpretation\r\n--- | ---\r\nNumber `N` | Exactly `N` arguments\r\nString `\"A-B\"`, where `A` and `B` are numbers | From `A` to `B` arguments\r\nString `\"N+\"`, where `N` is a number | `N` or more arguments\r\nString `\"?\"` | An optional argument\r\nString `\"*\"` | Any number of arguments\r\nString `\"+\"` | At least one argument\r\n\r\nIf more than one argument can be passed, a table is used to store the data. \r\n\r\n```lua\r\nparser:argument \"pair\"\r\n   :args(2)\r\n   :description \"A pair of arguments. \"\r\nparser:argument \"optional\"\r\n   :args \"?\"\r\n   :description \"An optional argument. \"\r\n```\r\n\r\n```bash\r\n$ lua script.lua foo bar\r\n```\r\n\r\n```\r\npair\t{foo, bar}\r\n```\r\n\r\n```bash\r\n$ lua script2.lua foo bar baz\r\n```\r\n\r\n```\r\npair\t{foo, bar}\r\noptional\tbaz\r\n```\r\n\r\n## Adding options\r\n\r\nOptions can be added using `:option()` method. It returns an Option instance, which can be configured in the same way as Parsers. The `name` field is required. An option can have several aliases, which can be set using `aliases` field or by continuously calling the Option instance. \r\n\r\n```lua\r\nparser:option \"-f\" \"--from\"\r\n```\r\n\r\n```bash\r\n$ lua script.lua --from there\r\n$ lua script.lua --from=there\r\n$ lua script.lua -f there\r\n$ lua script.lua -fthere\r\n```\r\n\r\n```\r\nfrom\tthere\r\n```\r\n\r\nFor an option, default index used to store data is the first 'long' alias (an alias starting with two control characters) or just the first alias, without control characters. \r\n\r\nSometimes it is useful to explicitly set the index using `target` field to improve readability of help messages. \r\n\r\n```lua\r\nparser:option \"-f\" \"--from\"\r\n   :target \"server\"\r\n```\r\n\r\n```bash\r\n$ lua script.lua --help\r\n```\r\n\r\n```\r\nUsage: script.lua [-f <server>] [-h]\r\n\r\nOptions: \r\n   -f <server>, --from <server>\r\n   -h, --help            Show this help message and exit. \r\n```\r\n\r\n```bash\r\n$ lua script.lua --from there\r\n```\r\n\r\n```\r\nserver\tthere\r\n```\r\n\r\n### Flags\r\n\r\nFlags are almost identical to options, except that they don't take an argument by default. \r\n\r\n```lua\r\nparser:flag \"-q\" \"--quiet\"\r\n```\r\n\r\n```bash\r\n$ lua script.lua -q\r\n```\r\n\r\n```\r\nquiet\ttrue\r\n```\r\n\r\n### Control characters\r\n\r\nThe first characters of all aliases of all options of a parser form the set of control characters, used to distinguish options from arguments. Typically the set only consists of a hyphen. \r\n\r\n### Setting number of arguments\r\n\r\nJust as arguments, options can be configured to take several command line arguments. \r\n\r\n```lua\r\nparser:option \"--pair\"\r\n   :args(2)\r\nparser:option \"--optional\"\r\n   :args \"?\"\r\n```\r\n\r\n```bash\r\n$ lua script3.lua --pair foo bar\r\n```\r\n\r\n```\r\npair\t{foo, bar}\r\n```\r\n\r\n```bash\r\n$ lua script3.lua --pair foo bar --optional\r\n```\r\n\r\n```\r\npair\t{foo, bar}\r\noptional\t{}\r\n```\r\n\r\n```bash\r\n$ lua script3.lua --optional=baz\r\n```\r\n\r\n```\r\noptional\t{baz}\r\n```\r\n\r\nNote that the data passed to `optional` option is stored in an array. That is necessary to distinguish whether the option was invoked without an argument or it was not invoked at all. \r\n\r\n### Setting number of invocations\r\n\r\nFor options, it is possible to control how many times they can be used. argparse uses `count` field to set how many times an option can be invoked. The value of the field is interpreted in the same way `args` is. \r\n\r\n```lua\r\nparser:option \"-e\" \"--exclude\"\r\n   :count \"*\"\r\n```\r\n\r\n```bash\r\n$ lua script.lua -eFOO -eBAR\r\n```\r\n\r\n```\r\nexclude\t{FOO, BAR}\r\n```\r\n\r\nIf an option can be used more than once and it can consume more than one argument, the data is stored as an array of invocations, each being an array of arguments. \r\n\r\nAs a special case, if an option can be used more than once and it consumes no arguments(e.g. it's a flag), than the number of invocations is stored in associated field of the result table. \r\n\r\n```lua\r\nparser:flag \"-v\" \"--verbose\"\r\n   :count \"0-2\"\r\n   :target \"verbosity\"\r\n   :description [[Sets verbosity level. \r\n-v: Report all warning. \r\n-vv: Report all debugging information. ]]\r\n```\r\n\r\n```bash\r\n$ lua script.lua -vv\r\n```\r\n\r\n```\r\nverbosity\t2\r\n```\r\n\r\n## Commands\r\n\r\nA command is a subparser invoked when its name is passed as an argument. For example, in luarocks CLI `install`, `make`, `build`, etc. are commands. Each command has its own set of arguments and options. \r\n\r\nCommands can be added using `:command()` method. Just as options, commands can have several aliases. \r\n\r\n```lua\r\nparser:command \"install\" \"i\"\r\n```\r\n\r\nIf a command it used, `true` is stored in the corresponding field of the result table. \r\n\r\n```bash\r\n$ lua script.lua install\r\n```\r\n\r\n```\r\ninstall\ttrue\r\n```\r\n\r\nA typo will result in an appropriate error message: \r\n\r\n```bash\r\n$ lua script.lua instal\r\n```\r\n\r\n```\r\nUsage: script.lua [-h] <command> ...\r\n\r\nError: unknown command 'instal'\r\nDid you mean 'install'?\r\n```\r\n\r\n### Adding elements to commands\r\n\r\nThe Command class is a subclass of the Parser class, so all the Parser's methods for adding elements work on commands, too. \r\n\r\n```lua\r\nlocal install = parser:command \"install\"\r\ninstall:argument \"rock\"\r\ninstall:option \"-f\" \"--from\"\r\n```\r\n\r\n```bash\r\n$ lua script.lua install foo --from=bar\r\n```\r\n\r\n```\r\ninstall\ttrue\r\nrock\tfoo\r\nfrom\tbar\r\n```\r\n\r\nCommands have their own usage and help messages. \r\n\r\n```bash\r\n$ lua script.lua install\r\n```\r\n\r\n```\r\nUsage: script.lua install [-f <from>] [-h] <rock>\r\n\r\nError: too few arguments\r\n```\r\n\r\n```bash\r\n$ lua script.lua install --help\r\n```\r\n\r\n```\r\nUsage: script.lua install [-f <from>] [-h] <rock>\r\n\r\nArguments: \r\n   rock\r\n\r\nOptions: \r\n   -f <from>, --from <from>\r\n   -h, --help            Show this help message and exit. \r\n```\r\n\r\n### Making a command optional\r\n\r\nBy default, if a parser has commands, using one of them is obligatory. \r\n\r\n```lua\r\nlocal parser = argparse()\r\nparser:command \"install\"\r\n```\r\n\r\n```bash\r\n$ lua script.lua\r\n```\r\n\r\n```\r\nUsage: script.lua [-h] <command> ...\r\n\r\nError: a command is required\r\n```\r\n\r\nThis can be changed using the `require_command` field. \r\n\r\n```lua\r\nlocal parser = argparse()\r\n   :require_command(false)\r\nparser:command \"install\"\r\n```\r\n\r\nNow not using a command is not an error:\r\n\r\n```bash\r\n$ lua script.lua\r\n```\r\n\r\nproduces nothing. \r\n\r\n## Default values\r\n\r\nFor elements such as arguments and options, if `default` field is set, its value is stored in case the element was not used. \r\n\r\n```lua\r\nparser:option \"-o\" \"--output\"\r\n   :default \"a.out\"\r\n```\r\n\r\n```bash\r\n$ lua script.lua\r\n```\r\n\r\n```\r\noutput\ta.out\r\n```\r\n\r\nThe existence of a default value is reflected in help message. \r\n\r\n```bash\r\n$ lua script.lua --help\r\n```\r\n\r\n```\r\nUsage: script [-o <output>] [-h]\r\n\r\nOptions: \r\n   -o <output>, --output <output>\r\n                         default: a.out\r\n   -h, --help            Show this help message and exit. \r\n```\r\n\r\nNote that invocation without required arguments is still an error. \r\n\r\n```bash\r\n$ lua script.lua -o\r\n```\r\n\r\n```\r\nUsage: script [-o <output>] [-h]\r\n\r\nError: too few arguments\r\n```\r\n\r\n### Default mode\r\n\r\nThe `defmode` field regulates how argparse should use the default value of an element. \r\n\r\nIf `defmode` contains `\"u\"`(for `unused`), the default value will be automatically passed to the element if it was not invoked at all. This is the default behavior. \r\n\r\nIf `defmode` contains `\"a\"`(for `argument`), the default value will be automatically passed to the element if not enough arguments were passed, or not enough invocations were made. \r\n\r\nConsider the difference: \r\n\r\n```\r\nparser:option \"-o\"\r\n   :default \"a.out\"\r\nparser:option \"-p\"\r\n   :default \"password\"\r\n   :defmode \"arg\"\r\n```\r\n\r\n```bash\r\n$ lua script.lua -h\r\n```\r\n\r\n```\r\nUsage: script [-o <o>] [-p [<p>]] [-h]\r\n\r\nOptions: \r\n   -o <o>                default: a.out\r\n   -p [<p>]              default: password\r\n   -h, --help            Show this help message and exit. \r\n```\r\n\r\n```bash\r\n$ lua script.lua\r\n```\r\n\r\n```\r\no\ta.out\r\n```\r\n\r\n```bash\r\n$ lua script.lua -p\r\n```\r\n\r\n```\r\no\ta.out\r\np\tpassword\r\n```\r\n\r\n```bash\r\n$ lua script.lua -o\r\n```\r\n\r\n```\r\nUsage: script [-o <o>] [-p [<p>]] [-h]\r\n\r\nError: too few arguments\r\n```\r\n\r\n## Converters\r\n\r\nargparse can perform automatic validation and conversion on arguments. If `convert` field of an element is a function, it will be applied to all the arguments passed to it. The function should return `nil` and, optionally, an error message if conversion failed. Standard `tonumber` and `io.open` functions work exactly like that. \r\n\r\n```lua\r\nparser:argument \"input\"\r\n   :convert(io.open)\r\nparser:option \"-t\" \"--times\"\r\n   :convert(tonumber)\r\n```\r\n\r\n```bash\r\n$ lua script.lua foo.txt -t5\r\n```\r\n\r\n```\r\ninput\tfile (0xaddress)\r\ntimes\t5 (number)\r\n```\r\n\r\n```bash\r\n$ lua script.lua nonexistent.txt\r\n```\r\n\r\n```\r\nUsage: script.lua [-t <times>] [-h] <input>\r\n\r\nError: nonexistent.txt: No such file or directory\r\n```\r\n\r\n```bash\r\n$ lua script.lua foo.txt --times=many\r\n```\r\n\r\n```\r\nUsage: script.lua [-t <times>] [-h] <input>\r\n\r\nError: malformed argument 'many'\r\n```\r\n\r\n### Table converters\r\n\r\nIf `convert` field of an element contains a table, arguments passed to it will be used as keys. If a key is missing, an error is raised. \r\n\r\n```lua\r\nparser:argument \"choice\"\r\n   :convert {\r\n      foo = \"Something foo-related\",\r\n      bar = \"Something bar-related\"\r\n   }\r\n```\r\n\r\n```bash\r\n$ lua script.lua bar\r\n```\r\n\r\n```\r\nchoice\tSomething bar-related\r\n```\r\n\r\n```bash\r\n$ lua script.lua baz\r\n```\r\n\r\n```\r\nUsage: script.lua [-h] <choice>\r\n\r\nError: malformed argument 'baz'\r\n```\r\n\r\n## Actions\r\n\r\nargparse can trigger a callback when an option or a command is encountered. The callback can be set using `action` field. Actions are called regardless of whether the rest of command line arguments are correct. \r\n\r\n```lua\r\nparser:flag \"-v\" \"--version\"\r\n   :description \"Show version info and exit. \"\r\n   :action(function()\r\n      print(\"script.lua v1.0.0\")\r\n      os.exit(0)\r\n   end)\r\n```\r\n\r\n```bash\r\n$ lua script.lua -v\r\n```\r\n\r\n```\r\nscript.lua v1.0.0\r\n```\r\n\r\nThis example would work even if the script had mandatory arguments. \r\n\r\n## Miscellaneous\r\n\r\n### Overwriting default help option\r\n\r\nIf the field `add_help` of a parser is set to false, no help option will be added to it. Otherwise, the value of the field will be used to configure it. \r\n\r\n```lua\r\nlocal parser = argparse()\r\n   :add_help {name = \"/?\"}\r\n```\r\n\r\n```bash\r\n$ lua script.lua /?\r\n```\r\n\r\n```\r\nUsage: script.lua [/?]\r\n\r\nOptions: \r\n   /?                    Show this help message and exit.\r\n```\r\n\r\n### Configuring usage and help messages\r\n\r\n#### Description and epilog\r\n\r\nThe value of `description` field of a parser is placed between the usage message and the argument list in the help message. \r\n\r\nThe value of `epilog` field is appended to the help message. \r\n\r\n```lua\r\nlocal parser = argparse \"script\"\r\n   :description \"A description. \"\r\n   :epilog \"An epilog. \"\r\n```\r\n\r\n```bash\r\n$ lua script.lua --help\r\n```\r\n\r\n```\r\nUsage: script [-h]\r\n\r\nA description. \r\n\r\nOptions: \r\n   -h, --help            Show this help message and exit. \r\n\r\nAn epilog. \r\n```\r\n\r\n#### Argument placeholder\r\n\r\nFor options and arguments, `argname` field controls the placeholder for the argument in the usage message. \r\n\r\n```lua\r\nparser:option \"-f\" \"--from\"\r\n   :argname \"<server>\"\r\n```\r\n\r\n```bash\r\n$ lua script.lua --help\r\n```\r\n\r\n```\r\nUsage: script.lua [-f <server>] [-h]\r\n\r\nOptions: \r\n   -f <server>, --from <server>\r\n   -h, --help            Show this help message and exit. \r\n```\r\n\r\n### Prohibiting overuse of options\r\n\r\nBy default, if an option is invoked too many times, latest invocations overwrite the data passed earlier. \r\n\r\n```lua\r\nparser:option \"-o\" \"--output\"\r\n```\r\n\r\n```bash\r\n$ lua script.lua -oFOO -oBAR\r\n```\r\n\r\n```\r\noutput   BAR\r\n```\r\n\r\nSet the `overwrite` field to false to prohibit this behavior. \r\n\r\n```lua\r\nparser:option \"-o\" \"--output\"\r\n   :overwrite(false)\r\n```\r\n\r\n```bash\r\n$ lua script.lua -oFOO -oBAR\r\n```\r\n\r\n```\r\nUsage: script.lua [-o <output>] [-h]\r\n\r\nError: option '-o' must be used at most 1 time\r\n```\r\n\r\n### Generating usage and help messages\r\n\r\n`:get_help()` and `get_usage:()` methods of Parser and Command classes can be used to generate their help and usage messages. \r\n\r\n### Parsing algorithm\r\n\r\nargparse interprets command line arguments in the following way: \r\n\r\nArgument | Interpretation\r\n--- | ---\r\n`foo` | An argument of an option or a positional argument. \r\n`--foo` | An option. \r\n`--foo=bar` | An option and its argument. The option must be able to take arguments. \r\n`-f` | An option. \r\n`-abcdef` | Letters are interpreted as options. If one of them can take an argument, the rest of the string is passed to it. \r\n`--` | The rest of the command line arguments will be interpreted as positional arguments. ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}